＜基本構文＞goto\n＜引数＞@label：ラベルを指定\n\n＜詳細＞指定したラベルにジャンプします。\ngosub（後述）と違い、行ったまま戻ってきません。\nまた、変数のスコープ（後述）が変化することもありません。
＜基本構文＞gosub\n＜引数＞@sub：サブルーチンのラベルを指定\n\n＜詳細＞サブルーチンをコールします。呼び出し先でreturnを実行すると呼び出し元に戻ってその次の命令から実行する。\n例）\ngosub @sub ;サブルーチンジャンプする\n.\n.\n@sub\n;なんらかの処理\nreturn ;呼び出し元の次の命令へ戻る
＜基本構文＞return\n＜引数＞なし\n\n＜詳細＞gosubやdefsubのサブルーチンを抜ける際に利用。\n※returnで引数にラベルを入れると、そのラベルに対して戻る（戻る場所を変更する）機能がある模様。\nただし、マニュアルにはその記載が見当たらない…？
＜基本構文＞if\n＜構文＞if then else endif文\n\n＜詳細＞条件分岐を記述できます。\nVisualBasic等と同様、一行if文と複数行if文が使える。\nthenの後改行すれば複数行if文、改行しなければ一行if文になります。\nelseとelseifが使えます。\nスペースを空けず、elseifと書いて下さい（これで一単語です）。\n複数行if文の場合は、elseがある場合その後も改行し、if文の終わりにはend ifもしくはendifと書いて下さい。\n
＜基本構文＞then\n＜構文＞if then else endif文\n\n＜詳細＞条件分岐を記述できます。\nVisualBasic等と同様、一行if文と複数行if文が使える。\nthenの後改行すれば複数行if文、改行しなければ一行if文になります。\nelseとelseifが使えます。\nスペースを空けず、elseifと書いて下さい（これで一単語です）。\n複数行if文の場合は、elseがある場合その後も改行し、if文の終わりにはend ifもしくはendifと書いて下さい。\n
＜基本構文＞else\n＜構文＞if then else endif文\n\n＜詳細＞条件分岐を記述できます。\nVisualBasic等と同様、一行if文と複数行if文が使える。\nthenの後改行すれば複数行if文、改行しなければ一行if文になります。\nelseとelseifが使えます。\nスペースを空けず、elseifと書いて下さい（これで一単語です）。\n複数行if文の場合は、elseがある場合その後も改行し、if文の終わりにはend ifもしくはendifと書いて下さい。\n
＜基本構文＞endif\n＜構文＞if then else endif文\n\n＜詳細＞条件分岐を記述できます。\nVisualBasic等と同様、一行if文と複数行if文が使える。\nthenの後改行すれば複数行if文、改行しなければ一行if文になります。\nelseとelseifが使えます。\nスペースを空けず、elseifと書いて下さい（これで一単語です）。\n複数行if文の場合は、elseがある場合その後も改行し、if文の終わりにはend ifもしくはendifと書いて下さい。\n
＜基本構文＞for\n＜構文＞for next文\n\n＜詳細＞変数を増やしながら（もしくは減らしながら）ループを実行します。\nfor 変数=初期値 to 終了値 (step 増分)でループ先頭、nextでループ終端を指定します。\n例）\nfor i=1 to 10\n  cprint i\nnext\nfor i=10 to 1 step -1\n  cprint i\nnext
＜基本構文＞next\n＜構文＞for next文\n\n＜詳細＞変数を増やしながら（もしくは減らしながら）ループを実行します。\nfor 変数=初期値 to 終了値 (step 増分)でループ先頭、nextでループ終端を指定します。\n例）\nfor i=1 to 10\n  cprint i\nnext\nfor i=10 to 1 step -1\n  cprint i\nnext
＜基本構文＞do\n＜構文＞do loop文\n\n＜詳細＞標準的なBASICにおけるdo loop文と同じです。\nただし、until文はありません。\n例）\n\ni=0\ndo while i<5\n  cprint i\n  i=i+1\nloop\ndo\n  cprint i\n  i=i-1\nloop while i>0\n;これは無限ループします。\ndo\n  cprint "!"\nloop
＜基本構文＞roop\n＜構文＞do loop文\n\n＜詳細＞標準的なBASICにおけるdo loop文と同じです。\nただし、until文はありません。\n例）\n\ni=0\ndo while i<5\n  cprint i\n  i=i+1\nloop\ndo\n  cprint i\n  i=i-1\nloop while i>0\n;これは無限ループします。\ndo\n  cprint "!"\nloop
＜基本構文＞exit\n＜用法＞do loopもしくはfor nextループを途中で抜ける\n\n＜詳細＞do loopもしくはfor nextループを途中で抜ける際に利用します。\nなお、スクリプト上のもっとも近いloopもしくはwhileの次へ抜けようとしますので、goto文でスクリプトの上でループの外に抜けてしまっていると正しく処理出来ません。\n処理の流れが読みにくくもなりますので、ループの中ではなるべくgoto文は使わない方がいいです。\n例）\n;5まででループが終わります。\nfor i=1 to 100\n  cprint i\n  if i==5 then exit\nnext\n
＜基本構文＞continue\n＜用法＞do loopもしくはfor nextループの頭に戻る\n\n＜詳細＞do loopもしくはfor nextループの頭に戻る際に利用します。\nなお、これらはスクリプト上のもっとも近いloopもしくはwhileの次へ戻ろうとしますので、goto文でスクリプトの上でループの外に抜けてしまっていると正しく処理出来ません。\n処理の流れが読みにくくもなりますので、ループの中ではなるべくgoto文は使わない方がいいです。\n例）\n;5より小さいときはcontinueでループ頭に戻るため、値が表示されません。\nfor i=1 to 10\n  if i<5 then continue\n  cprint i\nnext\n
＜基本構文＞defsub\n＜引数＞commandname：コマンド名（ラベルから@を取り除いたものを指定）\n　　　　paramlist：パラメータリスト（文字列）\n\n＜詳細＞ユーザー定義命令を作成します。commandnameが命令名になり、同じ名前のサブルーチンがその命令によってコールされます。\nparamlistは引数（パラメータ）のリストです。左から順番に第一引数、第二引数...です。引数がない場合は""にしてください。(C++で実装)\n＜TIPS：paramlistの文字指定＞\n"*"：以下の引数は全部型チェックをせずそのまま受け取る。数も制限無し \n"A"：どんな型でもひとつ受け取る。\n"N"：数値をひとつ受け取る。\n"S"：文字列をひとつ受け取る。シンボルやラベル名もこれで受け取ることが出来る。 \n"?"：その引数は、あってもなくてもよい。無い場合は、Luaではnil、BASICではシンボル#nilになる。?N ?S のように使う。\n"R"：vsetやvgetに使う変数名を受け取る。いわゆる「参照渡し」をするときに使う。\n"T"または"O"：テーブル記法を受け取る。結果は文字列になる。Lua側ではそれをbasic.decodetable(str)で処理する。\n"."：一つ前の引数が同じ型で任意の数続くことを表す。"S."や"N."のように使う。
＜実行制御：命令＞quit\n＜引数＞なし\n\n＜詳細＞エンジンを終了しウィンドウを閉じます。\nBASICのプログラム終了は一般的にendですが、luaではif文の終端にendを使うため、BASICでうっかりそう書くと何も言わずプログラムが終了して戸惑うことが多いので、あえて違う命令にしました。
＜実行制御：命令＞select\n＜引数＞"test1"：選択肢1に表示するテキスト\n　　　　@label1：選択肢1を選んだ際に遷移するラベル\n　　　　"test2"：選択肢2に表示するテキスト\n　　　　@label2：選択肢2を選んだ際に遷移するラベル...（以下、４つ以内で実装）\n\n＜詳細＞選択肢命令です。内部的にはラベル@selectbへのサブルーチンジャンプとして解釈されます。\n例）select "選択肢テキスト１",@label1,"選択肢テキスト２",@label2,"選択肢テキスト３",@label3
＜実行制御：命令＞skip\n＜引数＞flag：スキップモード番号\n\n＜詳細＞スキップモードを設定します。0で通常状態、1でスキップモード、2でオートモードです。(system.luaで実装) 
＜実行制御：命令＞trap\n＜引数＞@label：ラベルを指定\n\n＜詳細＞条件にあった入力があったときにlabelにジャンプします\n（この場合は自動でトラップモードが解除されます）。labelに#nilを指定するとトラップモードを解除します。\nスキップ条件は省略できます。\n省略した場合は全部指定、つまり"LRSEP"になります。\nL=左クリック R=右クリック S=スペースキー E=ENTERキー P=パッド入力、です。\n例）\ntrap @skip_demo\n.\n@skip_demo\ntrap #nil ; これがないと、クリックで飛ばさなかったときにトラップモードが解除されない。\ntrap @l_skip,"L" ; Lボタンをクリックしたときのみジャンプします。
＜実行制御：命令＞param\n＜引数＞var1：パラメータの値１\n　　　　var2：パラメータの値２\n　　　　var3：パラメータの値３………defsubで定義されたparamlistの数だけ指定する\n\n＜詳細＞defsubで定義された命令において、渡されたパラメータを受け取ります。
＜実行制御：命令＞vset\n＜引数＞vname：変数名の文字列\n　　　　value：代入する値\n\n＜詳細＞第一引数の文字列が示す変数名の変数に第二引数の値を代入します。defsub命令でparamlistが"R"のところは与えた変数名が文字列で入るので、そこへ代入するのに使います。
＜実行制御：命令＞call\n＜引数＞@label：ラベルを指定\n　　　　"paramlist"：文字列のパラメータリスト（指定するフォーマットはdefsub参照）\n　　　　param1：第一引数\n　　　　param2：第二引数（以下、必要な数だけ指定）\n\n＜詳細＞defsub定義無しであたかも命令のようにサブルーチンを呼ぶ命令です。\ndefsubは二重定義出来ず、プログラムの頭の方で設定しておく必要があるため、パラメーターは渡したいけど一時的にしか使わないような処理は、こちらで書くと便利なことがあります。\n例）\ncall @lb,"SN","test",4\n.\n@lb\nparam %s,%n\nfor %i=0 to %n\n  cprint %s\nnext\nreturn
＜実行制御：命令＞exec\n＜引数＞"basicsrc"：実行するBASICスクリプトの文字列\n\n＜詳細＞与えられた文字列をBASICスクリプトとして解釈し実行します。\n文字列変数も使えるので、場合によっては役立ちます。\n例）\nstr="beep"\nexec str ; beep命令が実行されます。
＜実行制御：命令＞getlogtext\n＜引数＞num：num個前のバックログを取得\n　　　　tag変数：取得した表示文のタグを受け取る変数\n　　　　text変数：取得した表示文のテキストを受け取る変数\n\n＜詳細＞num個前のバックログを取得します。tagとtextを受け取る変数をそれぞれ指定します。なお、取得できない場合は#nilが戻ります。\n現状、ノベルモードでも、得られる情報は表示文単位です。
＜実行制御：命令＞novelmode\n＜引数＞mode：モード番号\n\n＜詳細＞ノベルモードに設定します。mode=1でノベルモード、0でADVモード(0がデフォルト)です。\nノベルモードでは表示文ごとに自動で改ページされなくなるほか、いくつか専用の命令が使えるようになります。
＜実行制御：関数＞getskip\n＜引数＞なし\n\n＜詳細＞現在のスキップモードを取得します。\n0が通常時、1がスキップ、2がオートモードです\n例）\nif getskip()==1 then return ; スキップモード時はリターン
＜実行制御：関数＞logchk\n＜引数＞num：バックログ番号\n\n＜詳細＞バックログのデータが存在するかどうかチェックします。\nnum個前を調べます。\n例） if logchk(%n)==0 then 〜 ;バックログを処理したいときにこんな感じで。
＜実行制御：関数＞getconfig\n＜引数＞key：ラベルを指定\n\n＜詳細＞config.iniから値を取得します。keyもvalueも文字列です。詳しくはWindowsのiniファイルの仕様を調べて下さい。\n例） value=getconfig("chr_name")
＜実行制御：関数＞vget\n＜引数＞vname：変数名\n\n＜詳細＞引数の文字列が示す変数名値を返します。\ndefsub命令でparamlistが"R"のところは与えた変数名が文字列で入るので、そこから値を取得するのに使います。\n例）defsub test,"R"\n.\nv=125\ntest v\n\n@test\nparam %s\ncprint vget(%s) ; 125が戻ります。\nreturn\n
＜実行制御：関数＞getversion\n＜引数＞なし\n\n＜詳細＞NScripter2のバージョンを返します。
＜実行制御（ノベルモード専用）：命令＞newpage\n＜引数＞なし\n\n＜詳細＞改ページを実行します。
＜実行制御（ノベルモード専用）：命令＞gettextpos\n＜引数＞x変数：スプライト左上からの相対x座標\n　　　　y変数：スプライト左上からの相対y座標\n\n＜詳細＞TFORMAT SPFORMAT BFORMATのうち一番最後に実行した命令における次のテキスト行の先頭を戻します。\ntextbに渡るのはカーソル表示位置なので改行前ですが、こちらには改行後（次の行先頭）が渡ります。\nノベルゲームで選択肢を表示文の下に置きたいときや、FORMAT系で書き込んだ文字列の高さを知りたいときに使います。\nなお、得られる座標はスプライト左上からの相対座標です。
＜実行制御（ノベルモード専用）：命令＞skippause\n＜引数＞mode：ラベルを指定\n\n＜詳細＞mode=1で、改ページではないクリック待ちをスキップするモードになります。\nmode=0で通常と同じです。このモードはシステムセーブデータにセーブされます。
＜GUI処理：命令＞setscreen\n＜引数＞flag：スクリーンモード\n\n＜詳細＞スクリーンモードを指定します。\n0でウィンドウモード、1でフルスクリーンモードです。
＜GUI処理：命令＞shell\n＜引数＞"filename or url"：ファイル名、もしくはURL名\n\n＜詳細＞指定したファイルをシェルで開きます。\n実行ファイルなら実行されます。\nURLを指定すれば、そのURLを規定のブラウザで開きます。\n例）\nshell "notepad.exe"\nshell "http://www.google.co.jp"
＜GUI処理：命令＞caption\n＜引数＞"captionstr"：ウインドウのタイトルバー文字列\n\n＜詳細＞ウィンドウのタイトルバーに入る文字列を指定します。
＜GUI処理：命令＞setmouse\n＜引数＞x：X座標\n　　　　y：Y座標\n\n＜詳細＞マウスカーソルを指定した座標に移動します。
＜GUI処理：命令＞clearmouse\n＜引数＞なし\n\n＜詳細＞実行時点で処理されていない全てのマウスメッセージ（クリックなど）を消去します。
＜GUI処理：命令＞getclick\n＜引数＞lu変数[,ru変数,w変数,ld変数,rd変数] ：マウス情報\n\n＜詳細＞マウスクリックを取得します。\nluは左ボタンアップ、ruは右ボタンアップ、wはホイールアップ／ダウン、ldは左ボタンダウン、rdは右ボタンダウンです。\n例）\ngetclick %lu ; 必要の無い情報は省略できます。\ngetclick %lu,%ru
＜GUI処理：命令＞getmouse\n＜引数＞x：X座標\n　　　　y：Y座標\n\n＜詳細＞現在のマウス座標を取得します。\n画面外の場合は-1が戻ります。
＜GUI処理：命令＞doevents\n＜引数＞なし\n\n＜詳細＞メッセージを処理します。\n自前でループを回している場合、これを実行しないとメッセージ処理されません。\nボタン命令やclick命令等を実行している場合は内部で行っているので要りません。
＜GUI処理：命令＞sleep\n＜引数＞miliwait：スリープ時間\n\n＜詳細＞プログラムを指定した時間（単位はミリ秒）スリープさせてCPUに時間を明け渡します。\nスプライトなどのアニメーションまで止まってしまいますので、スプライトアニメーションをさせつつ時間待ちをしたい場合はwaitなどを使って下さい。
＜GUI処理：命令＞clearmessage\n＜引数＞なし\n\n＜詳細＞現状で処理されていないメッセージを消去します。
＜GUI処理：命令＞okbox\n＜引数＞text：ウインドウの文章\n　　　　caption：ウインドウタイトル\n\n＜詳細＞「ＯＫ」ボタンだけがあるダイアログを表示し、返答を待って動作を再開します。\n例）\nokbox "ウィンドウの文章がここにはいります。","ウィンドウタイトルです。"
＜GUI処理：命令＞yesnobox\n＜引数＞result変数：戻り値を格納する変数\n　　　　text：ウインドウの文章（疑問文が良い）\n　　　　caption：ウインドウタイトル\n\n＜詳細＞「はい」「いいえ」ボタンがあるダイアログを表示し、はいならば1、いいえならば0をresult変数に戻します。\n例）\nyesnobox %result,"ウィンドウの文章がここにはいります。","ウィンドウタイトルです。"\n;%resultには、はいならば1、いいえならば0が入っています。
＜GUI処理：命令＞input\n＜引数＞result変数：戻り値を格納する変数\n　　　　text：ウインドウの文章（疑問文が良い）\n　　　　caption：ウインドウタイトル\n\n＜詳細＞文字列を入力するダイアログを表示し、入力された文字列をresult変数に戻します。\n例）\ninput %result,"ウィンドウの文章がここにはいります。","ウィンドウタイトルです。"
＜GUI処理：命令＞resettimer\n＜引数＞なし\n\n＜詳細＞内部タイマをリセットします。\n0からミリ秒単位で時を刻み始めます。\n用例はwaittimerやgettimerを参照して下さい。
＜GUI処理：命令＞waittimer\n＜引数＞mili：指定時間ミリ秒\n\n＜詳細＞内部タイマが指定された時間になるまで待ちます。\n単位はミリ秒です。
＜GUI処理：命令＞time\n＜引数＞year変数：年\n　　　　month変数：月\n　　　　day変数：日\n　　　　hour変数：時\n　　　　min変数：分\n　　　　sec変数：秒\n\n＜詳細＞実行時点の年月日日時分秒を取得します。\n例）\ntime %year,%day,%hour,%min,%sec
＜GUI処理：命令＞beep\n＜引数＞[freq] ：周波数\n　　　　[mili]：鳴動ミリ秒\n\n＜詳細＞ビープ音を再生します。\n指定した周波数(freq)で指定した長さ(miliミリ秒)再生します。\n省略した場合デフォルトの長さと高さで再生されます。
＜GUI処理：命令＞gbegin\n＜引数＞なし\n\n＜詳細＞画面への描画を開始します。ここからgend命令の実行までの間は、画面描画を行うことが出来ます。\nこれはテクスチャ等を自前で描画する場合に必要な命令です。スプライト機能を使う場合は必要ありません。
＜GUI処理：命令＞gend\n＜引数＞なし\n\n＜詳細＞画面への描画を終了します。この命令の実行で、実際に画面に描画結果が反映されます。\nこれはテクスチャ等を自前で描画する場合に必要な命令です。スプライト機能を使う場合は必要ありません。
＜GUI処理：命令＞gblend\n＜引数＞mode：モード指定\n\n＜詳細＞画面描画のブレンディングモードを指定します。0が通常モードで、1が加算合成モードです。\nこれはテクスチャ等を自前で描画する場合に必要な命令です。スプライト機能を使う場合は必要ありません。
＜GUI処理：命令＞getpad\n＜引数＞padnum：パッド番号\n　　　　lx変数,ly変数,rx変数,ry変数：アナログスティックの数値\n　　　　dx,dy：デジタル方向ボタン数値\n　　　　a変数,b変数,x変数,y変数,start変数,back変数,l1変数,r1変数,l3変数,r3変数：ボタンの押下状況\n　　　　l2変数,r2変数：アナログトリガ数値\n\n＜詳細＞XInput方式のジョイパッドから入力を取得します。\npadnumはパッド番号です。\nlx,ly,rx,ryはアナログスティックの数値(-32768〜32767)dx,dyはデジタル方向ボタンの数値(-1〜1)です（Ｙ軸は上が正なので注意）、start back a b x y l1 r1 l3 r3は押されてなければ0、押されていれば1です。\nl2 r2はアナログトリガなので、0〜255で取得します。\nなお、情報の取得に失敗したときはlx変数に#nodataが戻ります。\n例）\ngetpad 0,%lx,%ly,%rx,%ry,%dx,%dy,%a,%b,%x,%y,%start,%back,%l1,%r1,%l2,%r2,%l3,%r3\nif %lx<>#nodata then\n  ;データ入力があったのでパッド処理\nend
＜GUI処理：命令＞ggetsize\n＜引数＞w：w変数\n　　　　h：h変数\n\n＜詳細＞ウィンドウの幅と高さを取得します。
＜GUI処理：関数＞getscreen\n＜引数＞なし\n\n＜詳細＞現在のスクリーンモードを取得します。0がウィンドウモード、1がフルスクリーンモードです。\n例）\nif getscreen()==1 then 〜;何かフルスクリーンモード用の処理
＜GUI処理：関数＞getkey\n＜引数＞keycode：キーコード\n\n＜詳細＞指定されたキーが押されているかどうかを取得します。\n一部マウスの取得も出来ます。\n例）if getkey("CTRL")==1 then 〜;CTRLが押されているときの処理\n英文字（例："A")もしくは数字キー……その文字の表すキー（数字はフルキーのほう）。大文字小文字は区別されない\n+ - * / . =……その文字の表すキー。\n" "もしくは"SPACE"……スペースキー\n"CTRL"……コントロールキー\n"UP"……カーソルキー上\n"DOWN"……カーソルキー下\n"LEFT"……カーソルキー左\n"RIGHT"……カーソルキー右\n"F1"〜"F12"……ファンクションキー\n"RETURN" もしくは "ENTER"……ENTERキー\n"PAGEUP"……ページアップキー\n"PAGEDOWN"……ページダウンキー\n"SHIFT"……シフトキー\n"SCROLLLOCK"……スクロールロックキー（ランプ付き状態なら1）\n"NUMLOCK"……ナムロックキー（ランプ付き状態なら1）\n"CAPSLOCK"……キャプスロックキー（ランプ付き状態なら1）\n"LBUTTON"……マウス左ボタン\n"RBUTTON"……マウス右ボタン\n"MBUTTON"……マウス中ボタン\n"NUM0"〜"NUM9"……テンキーの0〜9 
＜GUI処理：関数＞gettimer\n＜引数＞なし\n\n＜詳細＞resettimerから何ミリ秒経ったかを戻します。\n例）\nresettimer\n・\n・\nif gettimer()<1000 then 〜;１秒経ってない時にはなんらかの処理
＜コンソール処理：命令＞copen\n＜引数＞なし\n\n＜詳細＞コンソールを開きます。\n開くだけで何もしません。\nなお、これ以外のコンソール系の命令を実行しても自動で開きます。
＜コンソール処理：命令＞cclose\n＜引数＞なし\n\n＜詳細＞コンソールを閉じます
＜コンソール処理：命令＞ccaption\n＜引数＞"ウインドウタイトル"：コンソールのウインドウタイトルを変更します\n\n＜詳細＞コンソールのウィンドウタイトルを変更します。
＜コンソール処理：命令＞cprint\n＜引数＞param[,param2,param3,...] ：出力するパラメータ（複数指定可能）\n\n＜詳細＞与えたパラメータを連結してコンソールに表示します。\nパラメータは数値でも文字列でも構いません。\n最後に改行します。\n
＜コンソール処理：命令＞cwrite\n＜引数＞param[,param2,param3,...] ：出力するパラメータ（複数指定可能）\n\n＜詳細＞与えたパラメータを連結してコンソールに表示します。\nパラメータは数値でも文字列でも構いません。\nprintと違い、最後に改行がつきません。
＜コンソール処理：命令＞clocate\n＜引数＞x：カーソル移動先列番号\n　　　　y：カーソル移動先行番号\n\n＜詳細＞カーソルを移動し、次以降の表示をそこからにします。
＜コンソール処理：命令＞cgetsize\n＜引数＞変数w：幅の値を入れる変数\n　　　　変数h ：高さの値を入れる変数\n\n＜詳細＞コンソールの画面サイズを取得します。\nwが幅、hが高さです。\nclocateはこの範囲で指定して下さい。
＜コンソール処理：命令＞csetsize\n＜引数＞w：コンソールの幅\n　　　　h：コンソールの高さ\n\n＜詳細＞コンソールの画面サイズを設定します。wが幅、hが高さです。
＜コンソール処理：命令＞cgetcursor\n＜引数＞変数x：カーソルの現在の列番号\n　　　　変数y：カーソルの現在の行番号\n\n＜詳細＞コンソールの現在の表示位置を変数に取得します。
＜コンソール処理：命令＞csettext\n＜引数＞str：コンソール出力文字列\n　　　　x：文字列を表示する列番号\n　　　　y：文字列を表示する行番号\n　　　　[cr,cg,cb]：文字列カラー指定（RGB指定を0,1で行う）\n　　　　[br,bg,bb]：コンソール背景カラー指定（RGB指定を0,1で行う）\n　　　　[ci,bi]：強調するかのフラグ（色が明るくなる）\n\n＜詳細＞コンソールの文字列を指定位置に指定カラーで表示します。\nカラーは省略できます。\ncrcgcbは文字色（赤緑青）、brbgbbは背景色、これらは0か1です。\nciとbiは強調（色が明るくなる）です。\nこれも0か1です。
＜コンソール処理：命令＞cclear\n＜引数＞なし\n\n＜詳細＞コンソールをクリアします。
＜コンソール処理：命令＞ccolor\n＜引数＞cr,cg,cb：文字列カラー指定（RGB指定を0,1で行う）\n　　　　br,bg,bb：コンソール背景カラー指定（RGB指定を0,1で行う）\n　　　　ci,bi：強調するかのフラグ（色が明るくなる）\n\n＜詳細＞今後使う色を指定します。\ncrcgcbは文字色、brbgbbは背景色、これらは0か1です。\nciとbiは強調（色が明るくなる）です。これも0か1です。
＜コンソール処理：命令＞system\n＜引数＞"commandline"：コマンドライン\n\n＜詳細＞コンソールからコマンドプロンプトへ命令を送ります。\n例）\nsystem "dir" ; ディレクトリの内容を表示します。\nsystem "dir > out.txt" ; リダイレクトも出来ます。
＜コンソール処理：関数＞cread\n＜戻り値＞str：キーボードから取得した文字列\n\n＜詳細＞文字列をキーボードから一行取得します。
＜コンソール処理：関数＞cinkey\n＜引数＞c：１文字のデータ\n\n＜詳細＞一文字分の入力を取得します。\n改行を入力しなくても一文字だけ取得できます。
＜フォント処理：命令＞font\n＜引数＞"フォント名"：フォント名\n　　　　{フォント指定文字列}：フォントの詳細を指定\n\n＜詳細＞ゲーム中で使うフォントを作成します。\nフォント名は文字列で指定します。\nフォントの内容をテーブルで指定して下さい。\nフォントはセーブされません。\nスクリプトの最初で実行するといいでしょう。\n例）\n;全部デフォルト　font "text1",{}\n;普通のフォント\nfont "text2",{name="ＭＳ ゴシック",color=#FFFFFFFF,width=16,height=16}\n;袋文字\nfont "text3",{name="ＭＳ ゴシック",style="outline",outlinecolor=#FF000000,color=#FFFFFFFF,width=24,height=24}\n;影付き文字\nfont "text4",{name="ＭＳ ゴシック",style="shadow",color=#FFFFFFFF,shadowcolor=#FF000000,width=24,height=24}\n;袋文字＋字グラデーション\nfont "text5",{name="ＭＳ ゴシック",style="fancy",outlinecolor=#FF000000,color1=#FFFFEEAA,color2=#FFFFFFFF,shadowcolor=#FF000000,fx=1,fy=1,width=24,height=24}
＜フォント処理：命令＞fdelete\n＜引数＞"フォント名"：削除するフォント名\n\n＜詳細＞指定したフォントを削除します。
＜スプライト／ボタン処理：命令＞sp\n＜引数＞"スプライト名"：作成するスプライト名　例）"setname:spname" \nsetname=スプライトセット名、spname=スプライト名\n　　　　{テーブル指定文字列}：スプライトの詳細を指定\n\n＜詳細＞スプライトを作成します。\n同名のスプライトがある場合、それは削除されます。\n旧NScripterと違い、複数セル画像は全てのセルの画像をばらばらに指定します。\n画像としては連結しません。\nanimtimeを指定するとセルアニメーションします。アニメーションのタイプはanimtypeで指定します。（アニメーションについては本家マニュアル参照）\n例）\n;テーブル指定で指定されない値にはデフォルト値があります。\nsp "sp1",{name="test.png",x=100,y=100,z=100,a=128}\nsp "set:sp2",{name={"cell1.png","cell2.png"},x=200,y=200,z=100,cell=0,blend=1}\n;blendは0または省略で通常、1で加算ブレンド\nsp "set:sp2",{name={"cell1.png","cell2.png"},cx=300,cy=300,xs=1.2,ys=1.2,rot=45,z=100,cell=0}\n;角度はディグリー（度）単位です。ラジアンではありません。\nsp "set:sp3",{name={"cell1.png","cell2.png","cell3.png"},x=200,y=200,z=100,animtime=100,animtype="normal"}\nsp "set:sp4",{name="test.png",x=100,y=100,z=100,a=128,effect="nega"};ネガポジ反転\nsp "set:sp5",{name="test.png",x=100,y=100,z=100,a=128,effect="monotone",color=#FF3388FF};モノトーン\nsp "set:sp6",{name=":movieloopalpha(test.nmv)",x=0,y=0,z=0} ; ムービーテクスチャ\nsp "set:sp7",{name=":moviealpha(bomber.nmv)",x=100,y=200,z=0,delete=1} ;ムービーテクスチャ、再生が終わったら削除
＜スプライト／ボタン処理：命令＞spdelete\n＜引数＞"スプライト名"：消去するするプライト名\n\n＜詳細＞スプライトを消去します。
＜スプライト／ボタン処理：命令＞spdeletes\n＜引数＞"スプライト名前部分文字列" ：削除するスプライトに含まれる文字列\n\n＜詳細＞指定した文字列で始まるスプライトを全部削除します。例えば、spdeletes "set:test"とすれば、"set:testa""set:testb"...などがまとめて消去されます。
＜スプライト／ボタン処理：命令＞spcell\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　cellnum：セル番号を指定\n\n＜詳細＞スプライトのセル番号を切り替えます。\n0〜作るときに指定した画像の数-1までです。
＜スプライト／ボタン処理：命令＞spmove\n＜引数＞"スプライト名"：移動するスプライト名を指定\n　　　　x,y：x座標とy座標を指定\n　　　　[a]：透過度を指定\n\n＜詳細＞スプライトを指定位置に移動します。\naは省略すると255になります。
＜スプライト／ボタン処理：命令＞spmovelt\n＜引数＞"スプライト名"：移動するスプライト名を指定\n　　　　cx,cy：スプライトの左上のx座標とy座標を指定\n　　　　xs,ys：スプライトの右下のx座標とy座標を指定\n　　　　rot：回転させる角度を指定\n　　　　[a]：透過度を指定\n\n\n\n＜詳細＞スプライトを指定位置に拡大縮小回転を加えて移動します。\naは省略すると255になります。
＜スプライト／ボタン処理：命令＞spvisible\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　flag：表示、非表示を指定\n\n＜詳細＞スプライトの表示状態を切り替えます。\nflagが1で表示、0で非表示です。
＜スプライト／ボタン処理：命令＞spz\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　z：スプライトのZ値を指定\n\n＜詳細＞スプライトのZ値を切り替えます。\n小さい方が上に表示されます。
＜スプライト／ボタン処理：命令＞spfill\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　#色指定：スプライトを塗りつぶす色を指定\n\n＜詳細＞スプライトを指定した色で塗りつぶします。
＜スプライト／ボタン処理：命令＞spanimationreset\n＜引数＞なし\n\n＜詳細＞全てのスプライトのアニメーションをリセットします。
＜スプライト／ボタン処理：命令＞spset\n＜引数＞"スプライトセット名"：スプライトセット名を指定\n　　　　z：スプライトセットのZ値を指定\n\n＜詳細＞スプライトセットを作成します。\nスプライトセットのz値を指定できます。
＜スプライト／ボタン処理：命令＞spsetdelete\n＜引数＞"スプライトセット名"：スプライトセット名を指定\n\n＜詳細＞スプライトセットを削除します。
＜スプライト／ボタン処理：命令＞spsetclear\n＜引数＞"スプライトセット名"：スプライトセット名を指定\n\n＜詳細＞そのスプライトセットに属しているスプライトを全部削除します。\nスプライトセット自体は残ります。
＜スプライト／ボタン処理：命令＞spsetz\n＜引数＞"スプライトセット名"：スプライトセット名を指定\n　　　　z：スプライトセットのZ値を指定\n\n＜詳細＞スプライトセットのz値を変更します。
＜スプライト／ボタン処理：命令＞spsetvisible\n＜引数＞"スプライトセット名"：スプライトセット名を指定\n　　　　flag：表示、非表示を指定\n\n＜詳細＞スプライトセットの表情状態を切り替えます。\nflagが1で表示、0で非表示です。
＜スプライト／ボタン処理：命令＞spformat\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　cell：セル番号を指定\n　　　　"表示文字列"：出力する文字列\n　　　　{本文設定テーブル指定}：出力する文字列の設定を指定\n　　　　[{ルビ設定テーブル指定}]：ルビがある場合にはルビの設定を指定\n\n＜詳細＞指定スプライトの指定セルに文字列を書き込みます。\nこれはスプライトを書き換える命令であって、描画命令ではありません。\nたとえばバックログの文字列を作るとき等に使います。\nテキスト中に%p等がある場合は単に無視します。\nなお、ルビ機能を使わない場合はルビ設定は省略できます。\n例）\nspformat "sp1",0,"あいうえおかきくけこ{漢字/ルビ}さしすせそ",{font="text",x=2,y=2,w=25,h=4},{font="ruby"}\n;ここで、本文のx,yはピクセル単位でスプライトの左上からの座標、wとhは文字数単位で幅と高さです。
＜スプライト／ボタン処理：命令＞spputtext\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　cell：セル番号を指定\n　　　　"表示文字列"：出力する文字列\n　　　　{本文設定テーブル指定}：出力する文字列の設定を指定\n　　　　[{ルビ設定テーブル指定}]：ルビがある場合にはルビの設定を指定\n\n＜詳細＞スプライトに文字列を書き込み、それを逐次表示します。\nwaitで速度を調整できます。\n速度に0を指定したときは瞬時に全部を表示します。\nテキスト中の\pと文末で、BASICの@textbを呼び出してテキストウィンドウのクリック待ちのインタフェース処理をします。\nただし、文末が_で終わってる場合は文末でのインタフェース処理はしません。表示が終わるとそのまま次の行に実行を移します。\nデフォルトでは、この命令を実行すると改ページし、スプライトを無色透明でクリアし、指定したx,y座標から字を書き始めます。\nADV形式のゲームではこれでいいですが、ノベル形式（１クリック１ページではない、画面全体に字が出るゲーム）では不便なので、novelmodeという命令があります。\nnovelmode 1の状態では、文末で改ページクリック待ち\cを使えるようになります。\nこれを処理するかpageclear命令を処理するまで改ページされません。\n例）\nspputtext "sp1",0,"あいうえおかきくけこ{漢字/ルビ}さしすせそ",{font="text",x=2,y=2,w=25,h=4,wait=50},{font="ruby"}\n;x,yは文字を書き始める際の左上の座標、省略すると0,0。w,hは横と縦の文字数。waitは文字表示速度。\n;本文テーブルのfontは本文の、ルビテーブルのfontはルビのフォント。\n;ルビテーブルでpxやpyを指定すると、ルビの送り幅が指定できる（省略するとフォントの幅になる）
＜スプライト／ボタン処理：命令＞getscreenshot\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n\n＜詳細＞スプライトで構成されている現在の画面のスクリーンショットを取り、ビットマップオブジェクトに格納します。
＜スプライト／ボタン処理：命令＞btnclear\n＜引数＞["スプライトセット名",{デフォルトのスプライト操作文字列}]：ボタン設定をクリアするスプライトセット名\n\n＜詳細＞ボタン設定をクリアします。\n設定はスプライトセットごとに別です。\nデフォルトのスプライト操作文字列は、どのボタンにもカーソルが乗ってないときに実行されます。スプライト操作文字列についてはbtnstrの項目で解説します。\nなお、スプライトセット名を省略するとスプライトセット""、スプライト操作文字列を省略すると""（何もしない）になります。
＜スプライト／ボタン処理：命令＞btn\n＜引数＞"スプライト名"：ボタンにするスプライト名\n　　　　{ボタン設定テーブル}：ボタン設定をテーブルで指定\n\n＜詳細＞指定したスプライトをボタンにします。\non="スプライト操作文字列"　ボタンにカーソルが重なったときに実行する処理を指定します。省略すると自分自身をセル１にするものになります。\noff="スプライト操作文字列"　ボタンからカーソルが離れたときに実行する処理を指定します。省略すると自分自身をセル０にするものになります。\nstyle="スタイル指定"\n　ボタンのスタイルを指定します。省略すると"push"になります。次の種類があります。\n　"push" または"" プッシュボタン、重なっているときにセル1、離れているときにセル0を表示、戻り値はスプライト名です。\n　"toggle" トグルボタン 押すごとにセル0と1が切り替わります。戻り値は"スプライト名:0"もしくは"スプライト名:1"です。\n　"bar" バー セルをバーのように使って、スプライトの中のどこをクリックしたかでバーの位置が変わります。ちょっとややこしいのでサンプルを参照してください。\nalign="left" もしくは align="right"　バータイプのボタンで、スプライトのどちらの端を0にするかを選択します。省略時のデフォルトは"left"です。\nnotreset=1　プッシュボタンで、押した後に通常ならセルが0に戻りますが、1のまま戻らないようにします。
＜スプライト／ボタン処理：命令＞btnexec\n＜引数＞戻り値変数名：ボタンの戻り値を取得する変数を指定\n　　　　"スプライトセット名"：スプライトセット名を指定\n　　　　[{ボタン処理テーブル}]：ボタン処理テーブルの内容を指定\n\n＜詳細＞ボタン処理を実行し、戻り値を変数に返します。\n戻り値にはスプライトセット名は含まれません。（ボタン処理テーブルの内容、戻り値についてはマニュアル指定）\n;ここより前にwindow:btn1とwindow:btn2はロードされているものとする。\nbtnclear "window"\nbtn "window:btn1"\nbtn "window:btn2"\n@btnloop\nbtnexec %ret,"window"\nif %ret==#r then ;右クリック時の処理\nif %ret=="btn1" then ;ボタン１の時の処理\nif %ret=="btn2" then ;ボタン２の時の処理\ngoto @btnloop
＜スプライト／ボタン処理：命令＞btnstr\n＜引数＞"スプライト操作文字列"：スプライトの処理を実装\n\n＜詳細＞スプライト操作文字列を実行します。\nスプライト操作文字列はボタン処理にも使われますが、スプライト操作文字列を単体で実行するのがこの命令です。\n＜スプライト操作文字列＞\n"S(サウンドファイル名)"　そのサウンドを再生します。\n"P(スプライト名,セル番号)"　指定したスプライトを表示状態にし、セル番号を変更します。\nセル番号とありますが、これは整数の数値を直接書かなければなりません。\n変数は使えません。\n"C(スプライト名)"　指定したスプライトを非表示状態にします。\n"M(スプライト名,x,y)"　指定したスプライトを移動します。この座標にも整数を直接書いて下さい。変数は使えません。\nこれらはつなげて組み合わせることも出来ます。\n例）\nbtnstr "S(se/test.ogg)P(set:sp1,1)"
＜スプライト／ボタン処理：命令＞print\n＜引数＞#transition：#から始まるトランジションを指定\n　　　　[time]：トランジションさせる時間を指定\n　　　　[option]：追加オプションを指定（ユニバーサルトランジション時のファイル名）\n\n＜詳細＞スプライトの描画状態を変更すると、内部にその変化が蓄積されます。\nPRINT命令で実際に画面に反映することが出来ます。この仕様は旧NScripterと同じです。\nシンボルはトランジションの種類を指定します。時間の単位はミリ秒です。\n#c もしくは"" 瞬時表示 時間指定はいりません。\n#f クロスフェード\n#ru #rd #rl #rr ロール上下左右\n#su #sd #sl #sr スクロール上下左右\n#u ユニバーサルトランジション 三番目の引数にルール画像を取ります。\n旧NScripterのトランジション18番と同じです。\n例）print #c\nprint #rd,500\nprint #sl,500\nprint #f,500\nprint #u,500,"rule.png"\n
＜スプライト／ボタン処理：命令＞wait\n＜引数＞time：待ち時間\n　　　　[clickflag]：クリックで飛ばせるかどうか指定\n\n＜詳細＞指定した時間処理を中断します。\n時間の単位はミリ秒です。\nクリックフラグを1にするとクリックで飛ばせるようになります。\nなお、この命令の実行中もアニメーションなどは表示されます。\nsleepを使うとアニメーションも止まってしまうので、スプライトを使った普通のゲーム中はこちらを使うことが多いでしょう。
＜スプライト／ボタン処理：命令＞click\n＜引数＞なし\n\n＜詳細＞クリック待ちをします。\n左クリックで先へ進めます。\nアニメーションは実行されます。
＜スプライト／ボタン処理：命令＞lrclick\n＜引数＞なし\n\n＜詳細＞左右どちらのクリックでも飛ばせるクリック待ちをします。
＜スプライト／ボタン処理：命令＞spdraw\n＜引数＞なし\n\n＜詳細＞スプライト全てを描画します。\nこれはテクスチャなどの低水準描画命令と一緒にスプライトを描画したいときに使います。
＜スプライト／ボタン処理：命令＞getspinfo\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　変数info：スプライト情報infoの構造体\n\n＜詳細＞スプライト情報を取得します。\n構造体に情報を格納します。\n変数がinfoの場合は次のようになります。\n（通常のスプライトの場合）\ninfo.x ; X座標\ninfo.y ; Y座標\n（回転拡縮指定のスプライトの場合）\ninfo.cx ; CX座標\ninfo.cy ; CY座標\ninfo.xs ; X拡大率\ninfo.ys ; Y拡大率\ninfo.rot ; 回転角\n（どちらでも共通）\ninfo.z ; Z値\ninfo.a ; α値\ninfo.cell ; セル番号\ninfo.cellnum ; セルの数\ninfo.w ; 画像の幅\ninfo.h ; 画像の高さ\ninfo.animtype ; アニメーションタイプ\ninfo.animtime ; アニメーション時間\n
＜スプライト／ボタン処理：関数＞getspcell\n＜引数＞"スプライト名"：スプライト名を指定\n\n＜詳細＞定したスプライトの現在のセル番号を取得します。
＜スプライト／ボタン処理：関数＞sphitcheck\n＜引数＞"スプライト名"：スプライト名を指定\n　　　　x,y：座標(x,y)を指定\n\n＜詳細＞指定したスプライトの内側に座標x,yが含まれるなら1、含まれないなら0を返します。\n現状、拡大縮小回転タイプのスプライトには対応していない。
＜テクスチャ処理：命令＞tcreate\n＜引数＞"テクスチャ名"：テクスチャ名を指定\n　　　　w：幅\n　　　　h：高さ\n\n＜詳細＞空白のテクスチャを作成します。\n幅と高さを指定します。
＜テクスチャ処理：命令＞tload\n＜引数＞"テクスチャ名"：テクスチャを指定\n　　　　"画像ファイル名"：テクスチャ画像を指定\n\n＜詳細＞画像をテクスチャとしてロードします。
＜テクスチャ処理：命令＞tfromb\n＜引数＞"テクスチャ名"：テクスチャを指定\n　　　　"ビットマップ名"：ビットマップ画像を指定\n\n＜詳細＞ビットマップオブジェクトをテクスチャに変換します。
＜テクスチャ処理：命令＞tdelete\n＜引数＞"テクスチャ名"：削除するテクスチャ名\n\n＜詳細＞テクスチャを削除します。
＜テクスチャ処理：命令＞tdraw\n＜引数＞"テクスチャ名"：描画するテクスチャを指定\n　　　　x：x座標\n　　　　y：y座標\n　　　　a：透過度を指定\n\n＜詳細＞テクスチャを指定位置に指定の透過度で描画します。
＜テクスチャ処理：命令＞tdrawlt\n＜引数＞"テクスチャ名"：変化させるテクスチャ名\n　　　　cx,cy：テクスチャを描画開始するx座標、y座標\n　　　　xs,sy：拡大する加増のアドレス\n　　　　rot：拡大\n　　　　a：透明度\n\n＜詳細＞テクスチャを回転拡大縮小して描画します。
＜テクスチャ処理：命令＞tfill\n＜引数＞"テクスチャ名"：テクスチャ名を指定\n　　　　#色指定：テクスチャを塗りつぶす色\n\n＜詳細＞テクスチャを指定した色で塗りつぶします。
＜テクスチャ処理：命令＞tfrect\n＜引数＞"テクスチャ名"：テクスチャ名を指定\n　　　　lx,ly,rx,ry：範囲指定\n　　　　：#色指定：テクスチャを塗りつぶす色\n\n＜詳細＞テクスチャの(lx,ly)-(rx,ry)の範囲を指定色で塗りつぶします。
＜テクスチャ処理：命令＞tgetsize\n＜引数＞"テクスチャ名"\n　　　　幅変数名：テクスチャの幅を格納する変数を指定\n　　　　高さ変数名：高さを格納する変数を指定\n\n＜詳細＞テクスチャの幅と高さを取得します。
＜テクスチャ処理：命令＞tsave\n＜引数＞"テクスチャ名"：保存するテクスチャ名\n　　　　"セーブファイル名"：セーブファイル名\n\n＜詳細＞テクスチャの内容をpngファイルとしてセーブします。
＜テクスチャ処理：命令＞tbegin\n＜引数＞"テクスチャ名"：テクスチャ名を指定\n\n＜詳細＞テクスチャへの描画を開始します。
＜テクスチャ処理：命令＞tend\n＜引数＞なし\n\n＜詳細＞テクスチャへの描画を終了します。
＜テクスチャ処理：命令＞tformat\n＜引数＞"テクスチャ名"：文字列を書き込むテクスチャ名\n　　　　"表示文字列"：書き込む文字列\n　　　　{本文設定テーブル指定}：文字列の設定テーブルを指定\n　　　　[,{ルビ設定テーブル指定}]：ルビ指定\n\n＜詳細＞テクスチャに文字列を書き込みます。\n引数の詳細はspformatを参照して下さい。
＜テクスチャ処理：関数＞tisplaying\n＜引数＞"テクスチャ名"：ムービテクスチャ名を指定\n\n＜詳細＞ムービーテクスチャが再生中の場合は1、再生が終了している場合は0を戻します。
＜ビットマップ処理：命令＞bcreate\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　w：幅を指定\n　　　　h：高さを指定\n\n＜詳細＞空白のビットマップを作成します。
＜ビットマップ処理：命令＞bload\n＜引数＞"ビットマップ名"：ビットマップ名\n　　　　"画像ファイル名"：画像ファイル名を指定\n\n＜詳細＞画像ファイルからビットマップを作成します。\nビットマップという名前ですが、対応フォーマットはpngとjpegです。
＜ビットマップ処理：命令＞bfromt\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　"テクスチャ名"：テクスチャを指定\n\n＜詳細＞テクスチャをビットマップに変換します。
＜ビットマップ処理：命令＞bdelete\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n\n＜詳細＞ビットマップを削除する。
＜ビットマップ処理：命令＞bsave\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　"セーブファイル名"：ビットマップの保存ファイル名を指定\n　　　　[品質]：品質の数値指定\n\n＜詳細＞ビットマップを画像ファイルとして保存します。\n拡張子にpngを選べばPNGファイル、jpegもしくはjpgを選べばJPEGファイルになります\n（英字の大文字小文字はどちらでも構いません）。\nJPEGの場合のみ品質を0-100で指定できます。\n省略した場合は95になります。\nこの命令はWindows BMP形式には対応していませんのでご注意ください。
＜ビットマップ処理：命令＞bfill\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　#色指定：塗りつぶす色を指定\n\n＜詳細＞指定した色でビットマップを塗りつぶします。
＜ビットマップ処理：命令＞bfrect\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　lx,ly,rx,ry：範囲を指定\n　　　　#色指定：塗りつぶす色を指定\n\n＜詳細＞指定した色で(lx,ly)-(rx,ry)の範囲を塗りつぶします。
＜ビットマップ処理：命令＞breverse\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　xflag,yflag：指定した座標を反転させる\n\n＜詳細＞ビットマップを反転します。1を指定した軸を反転します。
＜ビットマップ処理：命令＞bresize\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　w：幅を指定\n　　　　h：高さを指定\n\n＜詳細＞画像を拡大縮小してサイズ変更します。\n幅と高さを指定します。
＜ビットマップ処理：命令＞btrim\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　lx,ly,rx,ry：範囲を指定\n\n＜詳細＞(lx,ly)-(rx,ry)の範囲を切り抜いてそこだけを同じ名前のビットマップにします。
＜ビットマップ処理：命令＞bjoinx\n＜引数＞"ビットマップ名１"：ビットマップ名１\n　　　　"ビットマップ名２"：ビットマップ名２（右にくっつけるビットマップを指定）\n\n＜詳細＞ビットマップ２をビットマップ１の右にくっつけて新しいビットマップ１にします。
＜ビットマップ処理：命令＞bjoiny\n＜引数＞"ビットマップ名１"：ビットマップ名１\n　　　　"ビットマップ名２"：ビットマップ名２（下にくっつけるビットマップを指定）\n\n＜詳細＞ビットマップ２をビットマップ１の下にくっつけて新しいビットマップ１にします。
＜ビットマップ処理：命令＞bgetsize\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　幅変数名：取得したビットマップの幅を格納する変数を指定\n　　　　高さ変数名：取得したビットマップの高さを格納する変数を指定\n\n＜詳細＞ビットマップの幅と高さを取得します。
＜ビットマップ処理：命令＞bdup\n＜引数＞"新ビットマップ名"：ビットマップ名を指定\n　　　　"コピー元ビットマップ名"：\n\n＜詳細＞ビットマップをコピーします。
＜ビットマップ処理：命令＞bgradation\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　\n\n＜詳細＞色１から色２へのグラデーションでビットマップを塗りつぶします。
＜ビットマップ処理：命令＞bnega\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n\n＜詳細＞ビットマップをネガポジ反転させます。
＜ビットマップ処理：命令＞bmonotone\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　#色指定：モノトーン化する色を指定\n\n＜詳細＞ビットマップを指定色でモノトーン化します。
＜ビットマップ処理：命令＞bbegin\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n\n＜詳細＞ビットマップへの描画を開始します。
＜ビットマップ処理：命令＞bend\n＜引数＞なし\n\n＜詳細＞ビットマップへの描画を終了します。
＜ビットマップ処理：命令＞bformat\n＜引数＞"ビットマップ名"：ビットマップ名を指定\n　　　　"表示文字列"：ビットマップに書き込む文字列\n　　　　{本文設定テーブル指定}：本文中設定のテーブルを指定\n　　　　[{ルビ設定テーブル指定}]：ルビ設定のテーブルを指定\n\n＜詳細＞ビットマップに文字列を書き込みます。\n引数の詳細はspformatを参照して下さい。
＜動画処理：命令＞movie\n＜引数＞filename：ファイル名を指定\n　　　　[clickskipflag]：クリックで飛ばすかどうかを設定\n\n＜詳細＞画面全体にムービーを再生します。\nclickskipflagに0を指定するとクリックで飛ばせなくなります。
＜動画処理：命令＞mreset\n＜引数＞なし\n\n＜詳細＞全ムービーテクスチャのアニメーションをリセット（最初から再生）します。
＜音声処理：命令＞bgmplay\n＜引数＞filename：ファイル名\n\n＜詳細＞ＯＧＧファイルをＢＧＭとして再生します。
＜音声処理：命令＞bgmplayonce\n＜引数＞filename：ファイル名\n\n＜詳細＞ＯＧＧファイルをＢＧＭとして再生します。こちらはループしません。
＜音声処理：命令＞bgmstop\n＜引数＞なし\n\n＜詳細＞ＢＧＭの再生を停止します。
＜音声処理：命令＞bgmfadeout\n＜引数＞militime：フェードアウト時間\n\n＜詳細＞ＢＧＭのフェードアウト時間を指定します。単位はミリ秒です。
＜音声処理：命令＞bgmvolume\n＜引数＞volume：ボリューム指定\n\n＜詳細＞ＢＧＭのボリュームを指定します。0〜-10000です（DirectXの仕様に合わせてあります）。\n0が最大で、-10000が完全無音ですが、-2000くらいでほとんど聞こえなくなります。\n実際に試していい感じの値にしてください。\nボリュームに関しては他のすべての音声処理で同じ範囲です。
＜音声処理：命令＞seplay\n＜引数＞ch：チャンネル番号\n　　　　filename：ファイルネーム\n\n＜詳細＞ＳＥを再生します。\nチャンネル番号とファイル名を指定してください。\nチャンネル番号は0-15です。
＜音声処理：命令＞seloop\n＜引数＞ch：チャンネル番号\n　　　　filename：ファイルネーム\n\n＜詳細＞ＳＥをループで再生します。\nチャンネル番号とファイル名を指定してください。\nチャンネル番号は0-15です。
＜音声処理：命令＞sestop\n＜引数＞ch：チャンネル番号\n\n＜詳細＞ＳＥの再生をストップします。チャンネル番号を指定してください。
＜音声処理：命令＞sestopall\n＜引数＞なし\n\n＜詳細＞すべてのチャンネルのＳＥの再生をストップします。
＜音声処理：命令＞sefadeout\n＜引数＞militime：フェードアウト時間を指定\n\n＜詳細＞ＳＥのフェードアウト時間を指定します。\n単位はミリ秒です。
＜音声処理：命令＞sevolume\n＜引数＞volume：SE全体のボリュームを指定\n\n＜詳細＞ＳＥ全体のボリュームを設定します。
＜音声処理：命令＞sechvolume\n＜引数＞ch：チャンネル番号\n　　　　volume：ボリュームを指定\n\n＜詳細＞あるチャンネルのボリュームを設定します。
＜音声処理：命令＞voiceplay\n＜引数＞filename：ファイル名\n　　　　[speed]：再生スピードを指定\n\n＜詳細＞ボイスを再生します。speedは省略できます。ここに２を指定すると倍速で再生します。\nなお、ファイル名に""を指定すると今鳴っているボイスが停止します。
＜音声処理：命令＞voicewait\n＜引数＞なし\n\n＜詳細＞ボイスの再生終了を待ちます。アニメーション等は実行されます。
＜音声処理：命令＞voicevolume\n＜引数＞volume：ボリュームを指定\n\n＜詳細＞ボイスのボリュームを設定します。
＜音声処理：命令＞bgvplay\n＜引数＞@label：ラベルを指定\n\n＜詳細＞ＢＧＶ(Back Ground Voice、台詞ボイス(VOICEPLAY命令)が再生されていないときにループで再生されるボイス）を再生します。\nchはチャンネルで0〜15です。\nファイル名に""を指定するとＢＧＶが停止します。
＜音声処理：命令＞bgvfadeout\n＜引数＞militime：フェードアウト時間を指定\n\n＜詳細＞ＢＧＶのフェードアウト時間を指定します。\n単位はミリ秒です。
＜音声処理：命令＞bgvvolume\n＜引数＞volume：ボリュームを指定\n\n＜詳細＞ＢＧＶのボリュームを設定します。
＜音声処理：命令＞sound\n＜引数＞"サウンド名"：サウンド名を指定\n\n＜詳細＞サウンドオブジェクトを作成します。\nsound sdelete splay sstop svolume span sfadeout spause sresume sisplayingは、サウンドオブジェクトを直接扱う命令です。\nBGMやSEやVOICEの命令も内部的にはこれで実現されています。\nこれらのオブジェクトはセーブ機能ではセーブされません。\nあまり直接使う機会はないかもしれません。実装詳細はsystem.luaの該当部分を読んでください。\nなお、BGM系命令はサウンドオブジェクト"BGM0"もしくは"BGM1"が交互に、ボイス命令は"VOICE"、SEは"SE0""SE1"、BGVは"BGV0""BGV1"...で処理されます。これらにSOUND系命令の機能を使いたい場合はこの名前でアクセスしてください。
＜音声処理：命令＞sdelete\n＜引数＞"サウンド名"：サウンド名を指定\n\n＜詳細＞サウンドオブジェクトを削除します。
＜音声処理：命令＞splay\n＜引数＞"サウンド名"：サウンド名を指定\n　　　　{name="サウンドファイル名",loop=ループフラグ(0か1),looppoint=ループ再開位置(秒単位、小数可),volume=ボリューム,pan=パン,speed=スピードフラグ(1か2),fadeintime=フェードイン時間(ミリ秒単位)}：サウンドのパラメータ指定\n\n＜詳細＞サウンドを再生します。\nnameだけは必須ですが、あとは省略できます。
＜音声処理：命令＞sstop\n＜引数＞"サウンド名"：サウンド名を指定\n\n＜詳細＞再生中のサウンドオブジェクトを停止します。\nオブジェクト自体はなくなりません。
＜音声処理：命令＞svolume\n＜引数＞"サウンド名"：サウンド名を指定\n　　　　vol：ボリュームを指定\n\n＜詳細＞サウンドオブジェクトのボリュームを設定します。\n他と同じく0〜-10000です。
＜音声処理：命令＞span\n＜引数＞"サウンド名"：サウンド名を指定\n　　　　pan：パンの値\n\n＜詳細＞サウンドをパン（左右に偏らせる処理）します。-10000〜10000で、真ん中が0です。
＜音声処理：命令＞sfadeout\n＜引数＞"サウンド名"：サウンド名を指定\n\n＜詳細＞サウンドをフェードアウトします。
＜音声処理：命令＞spause\n＜引数＞"サウンド名"：サウンド名を指定\n\n＜詳細＞サウンドの再生を一時停止します。
＜音声処理：命令＞sresume\n＜引数＞"サウンド名"：サウンド名を指定\n\n＜詳細＞一時停止していたサウンドの再生を再開します。
＜音声処理：関数＞getbgmvolume\n＜引数＞なし\n\n＜詳細＞ＢＧＭのボリュームを取得します。
＜音声処理：関数＞getsevolume\n＜引数＞なし\n\n＜詳細＞ＳＥのボリュームを取得します。
＜音声処理：関数＞getvoicevolume\n＜引数＞なし\n\n＜詳細＞ボイスのボリュームを取得します。
＜音声処理：関数＞getbgvvolume\n＜引数＞なし\n\n＜詳細＞ＢＧＶのボリュームを取得します。
＜音声処理：関数＞sisplaying\n＜引数＞"サウンド名"：再生中か確認するサウンド名を指定\n\n＜詳細＞サウンドオブジェクトが再生中なら1、停止していれば0を返します。
＜演出処理：命令＞transition\n＜引数＞"切り替え元画像"：切り替え元の画像\n　　　　"切り替え先画像"：切り替え先の画像\n　　　　rate：レートを指定\n　　　　typestr：タイプを指定する文字列を指定\n　　　　option：オプションを指定\n\n＜詳細＞トランジション途中の画像を描画する命令です。\nprint命令で行うトランジションは内部的にこれを呼び出しています。\nこれを使うのはトランジションをカスタマイズする場合でしょうから、詳しくはsystem.luaと、Luaマニュアルのほうを参照してください。
＜演出処理：命令＞quake\n＜引数＞[time]：エフェクトの時間を指定\n　　　　[num]：揺らす回数を指定\n　　　　[size]：揺らす幅を指定\n\n＜詳細＞画面を地震のように揺らします。\nエフェクトに掛ける時間、揺らす回数、揺らす幅を指定します。\n幅の単位はピクセルではありません。\n1=画面の1/32です。
＜セーブ／ロード／ファイル処理：命令＞save\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞load\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞savepoint\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞savemode\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞filetime\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞savetime\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞linsert\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞finsert\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：命令＞strsave\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：関数＞lchk\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：関数＞schk\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：関数＞tchk\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：関数＞filechk\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：関数＞fchk\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜セーブ／ロード／ファイル処理：関数＞strload\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：命令＞split\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：命令＞splita\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：命令＞vclear\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：命令＞vcopy\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞isdef\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞num\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞str\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞asc\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞chr\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞strf\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞type\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞replace\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞left\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞right\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞mid\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞trim\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞ltrim\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞rtrim\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞len\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞zlen\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞lcase\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞ucase\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞zenkaku\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞join\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞joina\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞search\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞regex_replace\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞vlen\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞vubound\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜変数の変換・配列・文字列処理：関数＞vlbound\n＜引数＞@label：ラベルを指定\n\n＜詳細＞
＜数学処理：命令＞randomseed\n＜引数＞num：擬似乱数\n\n＜詳細＞擬似乱数を初期化します。\n0を与えると起動後の時間を使って毎回違った初期化をします。\n同じ種で初期化したい場合は0以外の正の整数を指定してください。
＜数学処理：関数＞pi\n＜引数＞なし\n\n＜詳細＞円周率を返します。
＜数学処理：関数＞sin\n＜引数＞x：ラジアンを指定\n\n＜詳細＞サイン関数の値を返します。\nなお、以下すべての三角関数において、扱う角度の単位は「ラジアン」です。
＜数学処理：関数＞sinh\n＜引数＞x：ラジアンを指定\n\n＜詳細＞ハイパーボリックサイン関数の値を返します。
＜数学処理：関数＞cos\n＜引数＞x：ラジアンを指定\n\n＜詳細＞コサイン関数の値を返します。
＜数学処理：関数＞cosh\n＜引数＞x：ラジアンを指定\n\n＜詳細＞ハイパーボリックコサイン関数の値を返します。
＜数学処理：関数＞tan\n＜引数＞x：ラジアンを指定\n\n＜詳細＞タンジェント関数の値を返します。
＜数学処理：関数＞tanh\n＜引数＞x：ラジアンを指定\n\n＜詳細＞ハイパーボリックタンジェント関数の値を返します。
＜数学処理：関数＞asin\n＜引数＞x：ラジアンを指定\n\n＜詳細＞アークサイン関数の値を返します。
＜数学処理：関数＞acos\n＜引数＞x：ラジアンを指定\n\n＜詳細＞アークコサイン関数の値を返します。
＜数学処理：関数＞atan\n＜引数＞x：ラジアンを指定\n\n＜詳細＞アークタンジェント関数の値を返します。
＜数学処理：関数＞atan2\n＜引数＞x0,x1：それぞれラジアンを指定\n\n＜詳細＞アークタンジェント関数の値を返します。\n入力をx0/x1で与えます。\nx0に0を指定すると、x1が正の時π/2、負の時-π/2を返します。
＜数学処理：関数＞random\n＜引数＞なし\n\n＜詳細＞乱数を返します。\n値は0〜32ビット整数の上限までの整数なので、これをmodで余りを取る等して必要な乱数を得ます。
＜数学処理：関数＞exp\n＜引数＞x：乗数を指定\n\n＜詳細＞指数関数です。\n自然対数の底eのx乗を得ます。
＜数学処理：関数＞log\n＜引数＞x：logを取るxを指定\n\n＜詳細＞自然対数関数です。\n自然対数の底eを使って、ln(x)を得ます。
＜数学処理：関数＞log10\n＜引数＞x：logを取るxを指定\n\n＜詳細＞常用対数関数です。底10を使ってlog10(x)を得ます。
＜数学処理：関数＞rad\n＜引数＞x：角度（直角が90となる度数）を指定\n\n＜詳細＞ディグリー単位（普通の「度」です。直角が90度）の角度を与えると、ラジアンに変換した値を返します。
＜数学処理：関数＞deg\n＜引数＞x：ラジアンを指定\n\n＜詳細＞ラジアン単位の角度を与えるとディグリー単位に変換した値を返します。
＜数学処理：関数＞sqrt\n＜引数＞x：平方根を取る値を\n\n＜詳細＞xの平方根を返します。
＜数学処理：関数＞floor\n＜引数＞x：小数点以下を切り捨てる値を指定\n\n＜詳細＞切り捨て関数です。\nxの小数点以下を負の無限大方向に丸めた値を返します。\nNScripter2は整数型を持たず、すべての計算は実数で行われますので、この関数は座標などを扱うときによく使います。\n例）\ncprint floor(3.14) ; -> 3\ncprint floor(-1.5) ; -> -2 ; 小さい方に丸めています。
＜数学処理：関数＞ceil\n＜引数＞x：ラベルを指定\n\n＜詳細＞切り上げ関数です。\nxの小数点以下を正の無限大方向に丸めた値を返します。\nfloorは「床」ceilは「天井」なので、高い低いでイメージするとわかりやすいでしょう。
＜数学処理：関数＞abs\n＜引数＞x：絶対値をとる数値を指定\n\n＜詳細＞xの絶対値を返します。
＜数学処理：関数＞sgn\n＜引数＞x：符号を判定する数値を指定\n\n＜詳細＞符号関数です。\nxが正ならば1、0ならば0、負ならば-1を返します。
＜その他処理：命令＞lua\n＜引数＞str：文字列を指定\n\n＜詳細＞文字列strをLuaスクリプトとしてコンパイルし、実行します。
＜その他処理：命令＞luafile\n＜引数＞filename：ファイル名を指定\n\n＜詳細＞luaスクリプトファイルを読み込んで実行します。
＜その他処理：命令＞setclipboard\n＜引数＞str：文字列を指定\n\n＜詳細＞指定した文字列をクリップボードにテキストとしてコピーします。\n外部のテキストエディタ等にペースト出来ます。\nデバッグ機能などに使います。
＜その他処理：関数＞luaf\n＜引数＞str：文字列を指定\n\n＜詳細＞文字列をLuaスクリプトとして実行します。\n数値か文字列を返せます。\n内部的には、"return (" .. str .. ")" をコンパイルして実行し、戻った値をBASICにかえしています。